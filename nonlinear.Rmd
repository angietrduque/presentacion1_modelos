---
title: "*Uso de los MLG en los casos de asociaciones no linealeales entre las variables*"
author:  "Angie Rodríguez Duque & César Saavedra Vanegas"
date: "Octubre 30 de 2020"
output:
  ioslides_presentation:
    widescreen: true 
    smaller: true 
    transition: slower
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```


```{r warning=FALSE, include=F, paged.print=TRUE}
suppressMessages(library(deSolve))
suppressMessages(library(nlme))
suppressMessages(library(ggplot2))
suppressMessages(library(plotly))
suppressMessages(library(reshape2))

```


# Introducción
##

# Definición
##
<div style="text-align: justify">

Hasta ahora solo hemos considerado asociaciones lineales entre X e y, donde un aumento de delta en una variable explicativa continua xi produce el mismo cambio βi en y para todos los valores de xi. βi a veces se denomina **"Slope"** porque es un gradiente lineal. Una ecuación de regresión lineal simple con una sola pendiente lineal es:

$$E(Y_{i})=\beta_{0}+\beta_{1}x_{i}; \hspace{2cm} i=1,...,N. $$
Una asociación en forma de U se puede modelar agregando una versión cuadrática de la variable y un parámetro $\beta$ adicional:

$$E(Y_{i})=\beta_{0}+\beta_{1}x_{i}+\beta_{2}x^{2}_{i}; \hspace{2cm} i=1,...,N. $$

<div/>

# Centrar
##
<div style="text-align: justify">

En la práctica, cuando se utilizan transformaciones como la cuadrática, que pueden crear valores grandes de xi, puede resultar útil centrar las variables explicativas utilizando su media (x) y escalarlas utilizando su desviación estándar (de). Para mayor comodidad de notación, primero creamos una versión centrada y escalada de $x_i$:

$$\tilde{x}_{i}=\displaystyle{\frac{(x_{i}-\bar{x}_{i})}{sd}}$$
y se ajusta al modelo:

$$E(Y_{i})=\beta_{0}+\beta_{1}\tilde{x}_{i}+\beta_{2}\tilde{x}^{2}_{i}$$
<div/>

# Ejemplo en R
##
<div style="text-align: justify">

```{r echo=FALSE}
# https://rpubs.com/juanhklopper/Nonlinear-modeling-Intro-to-R-Modeling-Series
Ks <- c(100, 200, 150) 
n0 <- c(5, 5, 6)
r <- c(0.15, 0.2, 0.15)
time <- 1:50

logF <- function(time, K, n0, r){
  d <- K * n0 * exp(r*time) / (K + n0 * (exp(r*time) - 1))
  return(d)
}

set.seed(123)
dat <- data.frame(Group = character(),
                  Time = numeric(),
                  Count = numeric())

for(i in 1:3){
  Ab <- logF(time = time, K = Ks[i], n0 = n0[i], r = r[i])
  tmp <- data.frame(Group = paste0("G", i), Time = time,
                    Count = Ab + rnorm(time, 0, 5))
  dat <-rbind(dat, tmp)
}

plot_ly(data = dat,
        x = ~Time,
        y = ~Count,
        color = ~Group,
        type = "scatter",
        mode = "markers") %>% layout(title = "Growth over time for three groups", 
                                     yaxis = list(zeroline = F))
```




# Bibliografía
##



